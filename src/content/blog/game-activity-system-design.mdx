---
title: 游戏活动系统架构设计
date: 2023-12-20
excerpt: 分享如何设计可配置化的运营活动系统，实现活动与客户端代码解耦，让策划可以自主配置活动内容。
coverImage: /images/blog/activity-system.jpg
readingTime: 15 分钟
tags:
  - Unity
  - 游戏开发
  - 架构设计
---

# 游戏活动系统架构设计

在运营游戏中，活动系统是最频繁迭代的模块之一。一个好的活动系统架构可以极大提升开发效率。本文分享我在设计活动系统时的一些经验。

## 需求痛点

传统的活动开发模式：

1. 策划出活动需求文档
2. 客户端开发 UI 和逻辑
3. 服务器开发协议和数据
4. 联调测试
5. 发布上线

**问题：**
- 每个活动都需要客户端改代码
- 活动上线需要跟版本
- 相似活动重复开发

<Callout type="danger">
  在紧急活动需求面前，这种模式会导致开发压力巨大，容易出 Bug。
</Callout>

## 设计目标

- **配置化**：活动内容通过配置表定义
- **模块化**：活动由可复用的组件组成
- **热更新**：新活动不需要发客户端版本
- **可视化**：策划可以预览活动效果

## 架构设计

### 活动组件化

将活动拆分为可复用的组件：

```
活动页面
├── Banner 组件（头图、标题）
├── Tab 组件（多标签页）
├── 任务列表组件
├── 奖励预览组件
├── 进度条组件
└── 按钮组件
```

每个组件都有标准化的配置格式：

```json
{
  "type": "TaskList",
  "config": {
    "taskIds": [1001, 1002, 1003],
    "layout": "vertical",
    "showProgress": true
  }
}
```

### 活动配置结构

```csharp
[Serializable]
public class ActivityConfig
{
    public int activityId;
    public string activityName;
    public long startTime;
    public long endTime;
    public string prefabPath;
    public List<ComponentConfig> components;
}

[Serializable]
public class ComponentConfig
{
    public string componentType;
    public Dictionary<string, object> config;
}
```

### 活动管理器

```csharp
public class ActivityManager : Singleton<ActivityManager>
{
    private Dictionary<int, ActivityConfig> activities;
    
    public void LoadActivities()
    {
        // 从服务器获取活动配置
        var configJson = NetworkManager.Request("/api/activities");
        activities = JsonUtility.FromJson<List<ActivityConfig>>(configJson)
            .ToDictionary(a => a.activityId);
    }
    
    public bool IsActivityOpen(int activityId)
    {
        if (!activities.TryGetValue(activityId, out var config))
            return false;
            
        var now = TimeManager.ServerTime;
        return now >= config.startTime && now <= config.endTime;
    }
    
    public void OpenActivity(int activityId)
    {
        var config = activities[activityId];
        var prefab = ResourceManager.Load<GameObject>(config.prefabPath);
        var instance = Instantiate(prefab);
        
        var controller = instance.GetComponent<ActivityController>();
        controller.Initialize(config);
    }
}
```

## 组件实现示例

### 任务列表组件

```csharp
public class TaskListComponent : ActivityComponent
{
    [SerializeField] private Transform container;
    [SerializeField] private TaskItem itemPrefab;
    
    public override void Initialize(ComponentConfig config)
    {
        var taskIds = config.GetIntArray("taskIds");
        
        foreach (var taskId in taskIds)
        {
            var taskData = TaskManager.Instance.GetTask(taskId);
            var item = Instantiate(itemPrefab, container);
            item.SetData(taskData);
        }
    }
}
```

### 基类设计

```csharp
public abstract class ActivityComponent : MonoBehaviour
{
    public abstract void Initialize(ComponentConfig config);
    public virtual void OnShow() { }
    public virtual void OnHide() { }
    public virtual void Refresh() { }
}
```

## 配置工具

开发一个活动配置编辑器，让策划可以：

1. 可视化拖拽组件
2. 实时预览效果
3. 导出配置表

<Callout type="tip">
  使用 Unity Editor 的 UI Toolkit 可以快速开发编辑器工具。
</Callout>

## 版本兼容

当需要新的组件类型时，通过热更新下发：

1. **Lua 方案**：组件逻辑用 Lua 实现
2. **AB 方案**：组件 Prefab 打成 AssetBundle
3. **混合方案**：Prefab + Lua 配合

## 效果与收益

实施配置化活动系统后：

| 指标 | 之前 | 之后 |
|------|------|------|
| 新活动开发时间 | 3-5 天 | 0.5-1 天 |
| 客户端介入 | 每次必须 | 仅新组件 |
| Bug 率 | 较高 | 显著降低 |
| 策划自主度 | 低 | 高 |

## 总结

活动系统设计的核心思想：

1. **组件化**：复用胜过重复开发
2. **配置化**：数据驱动 UI
3. **工具化**：降低使用门槛

一个好的活动系统，可以让团队从繁琐的重复工作中解放出来，专注于创造更有价值的内容。
